/*
    @copyright 2018-2020, opaque@ctrlc.hu
    This file is part of libopaque

    libopaque is free software: you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public License
    as published by the Free Software Foundation, either version 3 of
    the License, or (at your option) any later version.

    libopaque is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with libopaque. If not, see <http://www.gnu.org/licenses/>.
*/

#include <stdio.h>
#include <assert.h>
#include "../opaque.h"
#include "../common.h"

typedef struct {
  uint8_t blind[crypto_core_ristretto255_SCALARBYTES];
  uint16_t pwdU_len;
  uint8_t pwdU[];
} Opaque_RegisterUserSec;

int main(void) {
  // test vector 1
  // create credential workflow

  uint8_t pwdU[]="CorrectHorseBatteryStaple";
  size_t pwdU_len = sizeof(pwdU) - 1;
  uint8_t ctx[OPAQUE_REGISTER_USER_SEC_LEN+pwdU_len];
  uint8_t regreq[crypto_core_ristretto255_BYTES];

  // create registration request
  if(0!=opaque_CreateRegistrationRequest(pwdU, pwdU_len, ctx, regreq)) return 1;
  // metadata is R blinding factor
  // "blind_registration": "c62937d17dc9aa213c9038f84fe8c5bf3d953356db01c4d48acb7cae48e6a504"
  const uint8_t blind_registration[] = {
       0xc6, 0x29, 0x37, 0xd1, 0x7d, 0xc9, 0xaa, 0x21,
       0x3c, 0x90, 0x38, 0xf8, 0x4f, 0xe8, 0xc5, 0xbf,
       0x3d, 0x95, 0x33, 0x56, 0xdb, 0x01, 0xc4, 0xd4,
       0x8a, 0xcb, 0x7c, 0xae, 0x48, 0xe6, 0xa5, 0x04
  };
  // assert match with test vector
  if(memcmp(((Opaque_RegisterUserSec*) &ctx)->blind,blind_registration, sizeof(blind_registration))!=0) {
    fprintf(stderr, "failed to reproduce reg req blind factor\n");
    dump(blind_registration, sizeof(blind_registration),                      "blind_registration");
    dump(((Opaque_RegisterUserSec*) &ctx)->blind, sizeof(blind_registration), "blind             ");
    exit(1);
  }
  // registration_request": "445df00a6e854aa2c31a277f188a0a9d87d01e9674361997731dd09388aa3a02
  const uint8_t registration_request[32] = {0x44, 0x5d, 0xf0, 0x0a, 0x6e, 0x85, 0x4a, 0xa2,
                                            0xc3, 0x1a, 0x27, 0x7f, 0x18, 0x8a, 0x0a, 0x9d,
                                            0x87, 0xd0, 0x1e, 0x96, 0x74, 0x36, 0x19, 0x97,
                                            0x73, 0x1d, 0xd0, 0x93, 0x88, 0xaa, 0x3a, 0x02};
  if(memcmp(registration_request, regreq, 32)!=0) {
    fprintf(stderr, "failed to reproduce reg req\n");
    dump(regreq, 32, "regreq");
    dump(registration_request, 32, "registration_request");
    exit(1);
  }

  // create registration response
  // prepare
  unsigned char
    rsec[OPAQUE_REGISTER_SECRET_LEN],
    resp[OPAQUE_REGISTER_PUBLIC_LEN];
  // "server_public_key": "18d5035fd0a9c1d6412226df037125901a43f4dff660c0549d402f672bcc0933"
  //const uint8_t pkS[crypto_scalarmult_BYTES] =
  //        {0x18, 0xd5, 0x03, 0x5f, 0xd0, 0xa9, 0xc1, 0xd6,
  //         0x41, 0x22, 0x26, 0xdf, 0x03, 0x71, 0x25, 0x90,
  //         0x1a, 0x43, 0xf4, 0xdf, 0xf6, 0x60, 0xc0, 0x54,
  //         0x9d, 0x40, 0x2f, 0x67, 0x2b, 0xcc, 0x09, 0x33};
  const uint8_t skS[crypto_scalarmult_SCALARBYTES] = {
     0x16, 0xeb, 0x9d, 0xc7, 0x4a, 0x3d, 0xf2, 0x03,
     0x3c, 0xd7, 0x38, 0xbf, 0x2c, 0xfb, 0x7a, 0x36,
     0x70, 0xc5, 0x69, 0xd7, 0x74, 0x9f, 0x28, 0x4b,
     0x2b, 0x24, 0x1c, 0xb2, 0x37, 0xe7, 0xd1, 0x0f};
  if(0!=opaque_CreateRegistrationResponse(regreq, skS, rsec, resp)) return 1;
  // verify test vectors
  // "registration_response": "94f21620ea418fd1011763fa55c79f10014c10f258aea86660dbbd391364087918d5035fd0a9c1d6412226df037125901a43f4dff660c0549d402f672bcc0933",
  const uint8_t registration_response [64] = {
     0x94, 0xf2, 0x16, 0x20, 0xea, 0x41, 0x8f, 0xd1,
     0x01, 0x17, 0x63, 0xfa, 0x55, 0xc7, 0x9f, 0x10,
     0x01, 0x4c, 0x10, 0xf2, 0x58, 0xae, 0xa8, 0x66,
     0x60, 0xdb, 0xbd, 0x39, 0x13, 0x64, 0x08, 0x79,
     0x18, 0xd5, 0x03, 0x5f, 0xd0, 0xa9, 0xc1, 0xd6,
     0x41, 0x22, 0x26, 0xdf, 0x03, 0x71, 0x25, 0x90,
     0x1a, 0x43, 0xf4, 0xdf, 0xf6, 0x60, 0xc0, 0x54,
     0x9d, 0x40, 0x2f, 0x67, 0x2b, 0xcc, 0x09, 0x33
  };

  if(memcmp(registration_response, resp, sizeof resp)!=0) {
    fprintf(stderr,"failed to reproduce registration_response\n");
    dump(resp, sizeof resp, "resp");
    dump(registration_response, sizeof registration_response, "registration_response");
    exit(1);
  }

  // finalize request
  // prepare params
  Opaque_Ids ids={0};
  unsigned char rrec[OPAQUE_REGISTRATION_RECORD_LEN]={0};
  uint8_t ek[crypto_hash_sha512_BYTES]={0};

  if(0!=opaque_FinalizeRequest(ctx, resp, &ids, rrec, ek)) return 1;

  // verify test vectors
  // "export_key": "5903fa9a4fbd8875cb2795dea53133cb1531538c77e91f3d9e5124c4863ff58069a281dac58c3a784f88aac410310380141d60fcdbbe7eefd3fa647722fb25c0",
  const uint8_t export_key[] = {0x59, 0x03, 0xfa, 0x9a, 0x4f, 0xbd, 0x88, 0x75,
                                0xcb, 0x27, 0x95, 0xde, 0xa5, 0x31, 0x33, 0xcb,
                                0x15, 0x31, 0x53, 0x8c, 0x77, 0xe9, 0x1f, 0x3d,
                                0x9e, 0x51, 0x24, 0xc4, 0x86, 0x3f, 0xf5, 0x80,
                                0x69, 0xa2, 0x81, 0xda, 0xc5, 0x8c, 0x3a, 0x78,
                                0x4f, 0x88, 0xaa, 0xc4, 0x10, 0x31, 0x03, 0x80,
                                0x14, 0x1d, 0x60, 0xfc, 0xdb, 0xbe, 0x7e, 0xef,
                                0xd3, 0xfa, 0x64, 0x77, 0x22, 0xfb, 0x25, 0xc0};
  if(memcmp(export_key, ek, sizeof export_key)!=0) {
    fprintf(stderr,"failed to reproduce export_key\n");
    dump(ek, sizeof ek, "ek");
    dump(export_key, sizeof export_key, "export_key");
    exit(1);
  }
  // "registration_upload": "82477dbe036ca08478bc273eb6698ba6503c00182dd2106e306984512cd8551f214561d18bc40e5d05336dfa6d2fafc60a4659012f52a61952cb79495f3b4eb698f676244a6f06e77762b9f1e490c08b866306abeeedba936aca06a6e6aa811c71b8f14b7a1059cdadc414c409064a22cf9e970b0ffc6f1fc6fdd539c46767759e1d1344f2c3be888ab81ecbdd1388f3759158c5e2944606031d0d6fdbe21a037896583800f13c69f6209cabc07cf34aff9b4afa24ee8d30eaeb0c0fd1a44ee1",
  const uint8_t registration_upload[192] = {
      0x82, 0x47, 0x7d, 0xbe, 0x03, 0x6c, 0xa0, 0x84,
      0x78, 0xbc, 0x27, 0x3e, 0xb6, 0x69, 0x8b, 0xa6,
      0x50, 0x3c, 0x00, 0x18, 0x2d, 0xd2, 0x10, 0x6e,
      0x30, 0x69, 0x84, 0x51, 0x2c, 0xd8, 0x55, 0x1f,
      0x21, 0x45, 0x61, 0xd1, 0x8b, 0xc4, 0x0e, 0x5d,
      0x05, 0x33, 0x6d, 0xfa, 0x6d, 0x2f, 0xaf, 0xc6,
      0x0a, 0x46, 0x59, 0x01, 0x2f, 0x52, 0xa6, 0x19,
      0x52, 0xcb, 0x79, 0x49, 0x5f, 0x3b, 0x4e, 0xb6,
      0x98, 0xf6, 0x76, 0x24, 0x4a, 0x6f, 0x06, 0xe7,
      0x77, 0x62, 0xb9, 0xf1, 0xe4, 0x90, 0xc0, 0x8b,
      0x86, 0x63, 0x06, 0xab, 0xee, 0xed, 0xba, 0x93,
      0x6a, 0xca, 0x06, 0xa6, 0xe6, 0xaa, 0x81, 0x1c,
      0x71, 0xb8, 0xf1, 0x4b, 0x7a, 0x10, 0x59, 0xcd,
      0xad, 0xc4, 0x14, 0xc4, 0x09, 0x06, 0x4a, 0x22,
      0xcf, 0x9e, 0x97, 0x0b, 0x0f, 0xfc, 0x6f, 0x1f,
      0xc6, 0xfd, 0xd5, 0x39, 0xc4, 0x67, 0x67, 0x75,
      0x9e, 0x1d, 0x13, 0x44, 0xf2, 0xc3, 0xbe, 0x88,
      0x8a, 0xb8, 0x1e, 0xcb, 0xdd, 0x13, 0x88, 0xf3,
      0x75, 0x91, 0x58, 0xc5, 0xe2, 0x94, 0x46, 0x06,
      0x03, 0x1d, 0x0d, 0x6f, 0xdb, 0xe2, 0x1a, 0x03,
      0x78, 0x96, 0x58, 0x38, 0x00, 0xf1, 0x3c, 0x69,
      0xf6, 0x20, 0x9c, 0xab, 0xc0, 0x7c, 0xf3, 0x4a,
      0xff, 0x9b, 0x4a, 0xfa, 0x24, 0xee, 0x8d, 0x30,
      0xea, 0xeb, 0x0c, 0x0f, 0xd1, 0xa4, 0x4e, 0xe1
  };
  if((sizeof rrec != sizeof registration_upload) || memcmp(registration_upload, rrec, sizeof rrec)!=0) {
    fprintf(stderr,"failed to reproduce registration_upload\n");
    dump(rrec, sizeof rrec, "rrec               ");
    dump(registration_upload, sizeof registration_upload, "registration_upload");
    exit(1);
  }

  uint8_t rec[OPAQUE_USER_RECORD_LEN];
  opaque_StoreUserRecord(rsec, rrec, rec);

  uint8_t sec[OPAQUE_USER_SESSION_SECRET_LEN+pwdU_len];
  uint8_t req[OPAQUE_USER_SESSION_PUBLIC_LEN];
  if(0!=opaque_CreateCredentialRequest(pwdU, pwdU_len, sec, req)) {
    return 1;
  }

  // "KE1": "845ecfd6a4aeb967581fe5cb77a8edd8ebadcf25469bb1f399018d468f36e334804133133e7ee6836c8515752e24bb44d323fef4ead34cde967798f2e9784f69f67926bd036c5dc4971816b9376e9f64737f361ef8269c18f69f1ab555e96d4a",
  const uint8_t ke1[96] = {
       0x84, 0x5e, 0xcf, 0xd6, 0xa4, 0xae, 0xb9, 0x67,
       0x58, 0x1f, 0xe5, 0xcb, 0x77, 0xa8, 0xed, 0xd8,
       0xeb, 0xad, 0xcf, 0x25, 0x46, 0x9b, 0xb1, 0xf3,
       0x99, 0x01, 0x8d, 0x46, 0x8f, 0x36, 0xe3, 0x34,
       0x80, 0x41, 0x33, 0x13, 0x3e, 0x7e, 0xe6, 0x83,
       0x6c, 0x85, 0x15, 0x75, 0x2e, 0x24, 0xbb, 0x44,
       0xd3, 0x23, 0xfe, 0xf4, 0xea, 0xd3, 0x4c, 0xde,
       0x96, 0x77, 0x98, 0xf2, 0xe9, 0x78, 0x4f, 0x69,
       0xf6, 0x79, 0x26, 0xbd, 0x03, 0x6c, 0x5d, 0xc4,
       0x97, 0x18, 0x16, 0xb9, 0x37, 0x6e, 0x9f, 0x64,
       0x73, 0x7f, 0x36, 0x1e, 0xf8, 0x26, 0x9c, 0x18,
       0xf6, 0x9f, 0x1a, 0xb5, 0x55, 0xe9, 0x6d, 0x4a
  };
  if(sizeof rrec != sizeof registration_upload) {
    fprintf(stderr,"len(ke1) != len(req)\n");
    dump(req, sizeof req, "req");
    dump(ke1, sizeof ke1, "ke1");
    exit(1);
  }
  if(memcmp(ke1, req, sizeof req)!=0) {
    fprintf(stderr,"failed to reproduce ke1\n");
    dump(req, sizeof req, "req");
    dump(ke1, sizeof ke1, "ke1");
    exit(1);
  }

  uint8_t cresp[OPAQUE_SERVER_SESSION_LEN];
  uint8_t sk[OPAQUE_SHARED_SECRETBYTES];
  uint8_t authU[crypto_auth_hmacsha512_BYTES];
  uint8_t context[10]="OPAQUE-POC";
  if(0!=opaque_CreateCredentialResponse(req, rec, &ids, context, sizeof context, cresp, sk, authU)) {
    return -1;
  }

  // "session_key": "440f3aaae8454aeaa1756132e90b9c9c6dcb48e600c65d680ddea7dc494302b5ffb481e3019cafa751b23ece49ba56a5fdd23adcea431635ed0746e8858747b3"
  const uint8_t session_key[64] = {
       0x44, 0x0f, 0x3a, 0xaa, 0xe8, 0x45, 0x4a, 0xea,
       0xa1, 0x75, 0x61, 0x32, 0xe9, 0x0b, 0x9c, 0x9c,
       0x6d, 0xcb, 0x48, 0xe6, 0x00, 0xc6, 0x5d, 0x68,
       0x0d, 0xde, 0xa7, 0xdc, 0x49, 0x43, 0x02, 0xb5,
       0xff, 0xb4, 0x81, 0xe3, 0x01, 0x9c, 0xaf, 0xa7,
       0x51, 0xb2, 0x3e, 0xce, 0x49, 0xba, 0x56, 0xa5,
       0xfd, 0xd2, 0x3a, 0xdc, 0xea, 0x43, 0x16, 0x35,
       0xed, 0x07, 0x46, 0xe8, 0x85, 0x87, 0x47, 0xb3
  };

  if(memcmp(session_key, sk, sizeof session_key)!=0) {
    fprintf(stderr,"failed to reproduce session_key\n");
    dump(sk, sizeof sk, "sk");
    dump(session_key, sizeof session_key, "session_key");
    exit(1);
  }

  // "KE2": "56ae8e786c822c19b345ae0be916e6c6b756fd885eeb1d8989d6c419b612084754f9341ca183700f6b6acf28dbfe4a86afad788805de49f2d680ab86ff39ed7fc04860471c4c0b3d43a35c162617453e635ceccc817b2fe91db0bf00d25f62a86ed751e54142be36f1610bac7881a2bc570da522a8d003376161517c849d05aa50733a448e9dbb794592d7fca4be7d5d46f3f1e8ec80a683cfe603e865045e798b2fde829342444f3a1354baa0942d88db644eeb0cea5cef619dd3b46f7f577bf9c5ec75a8cd571370add249e99cb8a8c43f6ef05610ac6e354642bf4fedbf696e77d4749eb304c4d74be9457c597546bc22aed699225499910fc913b3e90712af189340f7cb60cb959e7001652710146936b72a50fa7baac2569d583d9ced4a7a205b14119b39ab3628fdc151883b1deed7428afd75712ec97e78500e1096b0",
  const uint8_t ke2[] = {
       0x56, 0xae, 0x8e, 0x78, 0x6c, 0x82, 0x2c, 0x19, 0xb3, 0x45, 0xae, 0x0b,
       0xe9, 0x16, 0xe6, 0xc6, 0xb7, 0x56, 0xfd, 0x88, 0x5e, 0xeb, 0x1d, 0x89,
       0x89, 0xd6, 0xc4, 0x19, 0xb6, 0x12, 0x08, 0x47, 0x54, 0xf9, 0x34, 0x1c,
       0xa1, 0x83, 0x70, 0x0f, 0x6b, 0x6a, 0xcf, 0x28, 0xdb, 0xfe, 0x4a, 0x86,
       0xaf, 0xad, 0x78, 0x88, 0x05, 0xde, 0x49, 0xf2, 0xd6, 0x80, 0xab, 0x86,
       0xff, 0x39, 0xed, 0x7f, 0xc0, 0x48, 0x60, 0x47, 0x1c, 0x4c, 0x0b, 0x3d,
       0x43, 0xa3, 0x5c, 0x16, 0x26, 0x17, 0x45, 0x3e, 0x63, 0x5c, 0xec, 0xcc,
       0x81, 0x7b, 0x2f, 0xe9, 0x1d, 0xb0, 0xbf, 0x00, 0xd2, 0x5f, 0x62, 0xa8,
       0x6e, 0xd7, 0x51, 0xe5, 0x41, 0x42, 0xbe, 0x36, 0xf1, 0x61, 0x0b, 0xac,
       0x78, 0x81, 0xa2, 0xbc, 0x57, 0x0d, 0xa5, 0x22, 0xa8, 0xd0, 0x03, 0x37,
       0x61, 0x61, 0x51, 0x7c, 0x84, 0x9d, 0x05, 0xaa, 0x50, 0x73, 0x3a, 0x44,
       0x8e, 0x9d, 0xbb, 0x79, 0x45, 0x92, 0xd7, 0xfc, 0xa4, 0xbe, 0x7d, 0x5d,
       0x46, 0xf3, 0xf1, 0xe8, 0xec, 0x80, 0xa6, 0x83, 0xcf, 0xe6, 0x03, 0xe8,
       0x65, 0x04, 0x5e, 0x79, 0x8b, 0x2f, 0xde, 0x82, 0x93, 0x42, 0x44, 0x4f,
       0x3a, 0x13, 0x54, 0xba, 0xa0, 0x94, 0x2d, 0x88, 0xdb, 0x64, 0x4e, 0xeb,
       0x0c, 0xea, 0x5c, 0xef, 0x61, 0x9d, 0xd3, 0xb4, 0x6f, 0x7f, 0x57, 0x7b,
       0xf9, 0xc5, 0xec, 0x75, 0xa8, 0xcd, 0x57, 0x13, 0x70, 0xad, 0xd2, 0x49,
       0xe9, 0x9c, 0xb8, 0xa8, 0xc4, 0x3f, 0x6e, 0xf0, 0x56, 0x10, 0xac, 0x6e,
       0x35, 0x46, 0x42, 0xbf, 0x4f, 0xed, 0xbf, 0x69, 0x6e, 0x77, 0xd4, 0x74,
       0x9e, 0xb3, 0x04, 0xc4, 0xd7, 0x4b, 0xe9, 0x45, 0x7c, 0x59, 0x75, 0x46,
       0xbc, 0x22, 0xae, 0xd6, 0x99, 0x22, 0x54, 0x99, 0x91, 0x0f, 0xc9, 0x13,
       0xb3, 0xe9, 0x07, 0x12, 0xaf, 0x18, 0x93, 0x40, 0xf7, 0xcb, 0x60, 0xcb,
       0x95, 0x9e, 0x70, 0x01, 0x65, 0x27, 0x10, 0x14, 0x69, 0x36, 0xb7, 0x2a,
       0x50, 0xfa, 0x7b, 0xaa, 0xc2, 0x56, 0x9d, 0x58, 0x3d, 0x9c, 0xed, 0x4a,
       0x7a, 0x20, 0x5b, 0x14, 0x11, 0x9b, 0x39, 0xab, 0x36, 0x28, 0xfd, 0xc1,
       0x51, 0x88, 0x3b, 0x1d, 0xee, 0xd7, 0x42, 0x8a, 0xfd, 0x75, 0x71, 0x2e,
       0xc9, 0x7e, 0x78, 0x50, 0x0e, 0x10, 0x96, 0xb0
  };

  if(sizeof cresp != sizeof ke2) {
    fprintf(stderr,"len(ke2) != len(resp)\n");
    dump(cresp, sizeof cresp, "resp");
    dump(ke1, sizeof ke2, "ke2");
    exit(1);
  }
  if(memcmp(ke2, cresp, sizeof cresp)!=0) {
    fprintf(stderr,"failed to reproduce ke2\n");
    dump(cresp, sizeof cresp, "resp");
    dump(ke2, sizeof ke2, "ke2");
    exit(1);
  }

  uint8_t skU[OPAQUE_SHARED_SECRETBYTES];
  uint8_t authUu[crypto_auth_hmacsha512_BYTES];
  uint8_t export_keyU[crypto_hash_sha512_BYTES];
  Opaque_Ids ids1={0};
  opaque_RecoverCredentials(cresp, sec, context, sizeof context, &ids1, skU, authUu, export_keyU);

  if(memcmp(session_key, skU, sizeof session_key)!=0) {
    fprintf(stderr,"failed to reproduce session_key\n");
    dump(skU, sizeof skU, "skU");
    dump(session_key, sizeof session_key, "session_key");
    exit(1);
  }

  if(memcmp(export_key, export_keyU, sizeof export_key)!=0) {
    fprintf(stderr,"failed to reproduce export_key\n");
    dump(export_keyU, sizeof export_keyU, "export_keyU");
    dump(export_key, sizeof export_key, "export_key");
    exit(1);
  }

  if(memcmp(authU, authUu, sizeof authU)!=0) {
    fprintf(stderr,"failed to reproduce authU\n");
    dump(authUu, sizeof authUu, "authUu");
    dump(authU, sizeof authU, "authU");
    exit(1);
  }

  return 0;
}
